Assignment 3 - Tic-Tac-Toe Build Steps 1) If you do not have Node.js installed, go to https://nodejs.org/en and install the LTS package for your operating system. 2) If you want to learn how to setup and create the react app manually, follow these instructions. 1) In your local development environment, open up your IDE (ie Visual Studio Code) and create a folder for your project. 2) Once your folder is open, open the terminal in your IDE and type in “npx create-react-app {name-of-app}” (for us this will be tic-tac-toe). —> npx create-react-app tic-tac-toe 3) Wait for the necessary packages to be installed. 4) Once everything is done being installed, delete everything in the folder, but leave the following files: a) package.json / package-lock.json b) the /public directory i) index.html inside the directory c) /src directory i) App.css ii) App.js iii) index.js iiii) index.css 5) From here, go to the site https://react.dev/learn/tutorial-tic-tac-toe and look at the CodeSandbox given in the tutorial. Copy and paste the code over from each file into your project. 6) To check if the setup is successful, cd into your project directory (cd tic-tac-toe) and run the command “npm start” 7) If successful, then congrats! You have successfully set up your first react project. 3) However, if you want to get a copy of the existing tutorial, then go to https://react.dev/learn/tutorial-tic-tac-toe and go to the “Setup for the tutorial” section, and press “fork” on the upper right hand corner of the shown code. This will take you to the codesandbox site, where you can fork the shown project code by logging in with your GitHub. a) Follow the directions on how to fork accordingly. If successful, you should have the same project they are showing in your local computer. 4) Look at the tutorial and at the section called “Building the Board”. Here you will learn how to build the rest of the board in a 3 x 3 square. a) When attempting to copy and paste this code: ``` export default function Square() { return <button className="square">X</button><button className="square">X</button>; } ``` You’ll get this error: /src/App.js: Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>? This means you have to wrap the item you’re returning in a JSX statement, or like so: ``` export default function Square() { return ( <> <button className="square">X</button> <button className="square">X</button> </> ); } ``` b) Now copy and paste the Button components in the code until you have 9 squares on the board, with 3 rows, creating a 3x3 square. Every 3 squares should be wrapped in a div with a class name of “board-row”. The end code result should look like this: ``` export default function Square() { return ( <> <div className="board-row"> <button className="square">1</button> <button className="square">2</button> <button className="square">3</button> </div> <div className="board-row"> <button className="square">4</button> <button className="square">5</button> <button className="square">6</button> </div> <div className="board-row"> <button className="square">7</button> <button className="square">8</button> <button className="square">9</button> </div> </> ); } ``` c) There should now be 9 squares rendered on the screen with a different number in each one. If not, make sure you have imported the ‘styles.css’ file correctly in your ‘index.js’ file. 5) Once you have the square rendered correctly, it is time to move on to the next step. Next, you are going to want to be able to change the value of a square from empty to “X” when a user clicks on the square. 1. Using React’s architecture of components, we can create reusable code to show the Square. You can do this through something called “Props” in React. 2. To do this, rename the “Square” component to “Board” instead. 3. Then create a new function component called “Square”. We will be using this ro return the button component instead. If done correctly, we should have the same square as earlier but with the number 1 in all of them instead. This is good! This means the components are working correctly. 4. Next you are going to want to show the accurate values. We can do this by updating the prop in the Square component. We can do this like so: ``` function Square({ value }) { return <button className="square">value</button>; } ``` 5. This will show the word “value” in all the squares. But we don’t want that do we? In Tic-Tac-Toe, we want users to start off with an empty board. This is because we are not rendering the value variable passed in properly. 1. We can fix this by making this minor adjustment. Add { } around the value variable. ``` function Square({ value }) { return <button className="square">{value}</button>; } ``` * The board should now be empty. 1. To see the numbers like we did before, we have to pass the prop through the component. We can do this by adding a “value’ when we call the component, like so: ``` export default function Board() { return ( <> <div className="board-row"> <Square value="1" /> <Square value="2" /> <Square value="3" /> </div> <div className="board-row"> <Square value="4" /> <Square value="5" /> <Square value="6" /> </div> <div className="board-row"> <Square value="7" /> <Square value="8" /> <Square value="9" /> </div> </> ); } ``` 6) Now we want to make the component **interactive**. We can do this by adding a function to handle when a user clicks on a square. 1. But which component do we add this to? The square component? Or the board component? We are going to want to add the Square component because we want each square to be clickable. 2. In the Square component, add a function called “handleClick()”. And in the button element in the return, add a keyword called “onClick” that calls that handle click function. 1. If this works successfully, then every time you press a number on the board, your console should say “clicked!” 2. 7) Now instead of numbers, we want X’s to start showing instead. Luckily, React components has this special function called “useState” that allows the component to “remember” previous states. 1. In order to use this special function, add this to the top of your code: ``` import { useState } from 'react'; ``` 2. Then, in your Square function, remove the value prop you put in earlier and add the state variable like so: ``` function Square() { const [value, setValue] = useState(null); function handleClick() { //… ``` 1. In this code, the “value” state variable is used to store the state, and setValue is used as a function to set the state and change the value. We can set the useState to null because we want to instantiate the default variable to nothing first as it has no value before being clicked. 1. Also remove the value from the Square inside the Board component. We won’t be needing this anymore because we will be using the state variable instead. 2. In your handleClick() function, change the console.log to use setValue(‘X’) instead. 1. If this works, then every time you press on a square, an ‘X’ should appear. 8) Now that we can show X’s whenever we click on the square, how can we pass that data to the Board component so we know when they win? We have to do this through the process of parent and child components. 1. Let Board be the parent component and Square be the child components. We need the child components to interact with each other. To collect the data from multiple children (in our case multiple Square components) 2. You can do this by editing the Board component to have a new state variable that has a default array of null like so: ``` // ... export default function Board() { const [squares, setSquares] = useState(Array(9).fill(null)); return ( // ... ); } ``` 3. Now the Board component can pass this data down to the child component, or the Square component 1. Do this by adding the value prop to the Board component and the Square component again. 2. Your resulting code should have this: In your Board Component: <Square value={squares[0]}/> In your Square Component: function Square({value}) { //… return ( <button className=”square” > {value} </button> ;) 3. The result of this should be an empty square. 9) Now we have to update the board upon click. We can do this by passing in another prop called “onSquareClick” into the Square child component. We can handle the handleClick function in the Board component. * Add a handleClick function inside the Board component that accepts a number i as a variable and add the prop variable onSquareClick={handleClick(0)} in the Square component * This will be used to show the X on each individual square in the Board * However, this leads to an error doesn’t it? This error is because the handleClick function to update the board is being called every time the board is clicked, but because handleClick alters the state of the board by calling setSquares every single time, there will be an infinite loop. The key thing here is that you do not want to call the handleClick function the user clicks, rather than being called right away on render as it is now. * To resolve this, use the arrow function instead when calling the handleClick function. 10) Use this arrow function like so: <Square value={squares[0]} onSquareClick={() => handleClick(0)} /> * Now the state of the entire board is controlled by the board itself, and the Square components are only responsible for its own values. Next Step: Adding O’s 1. Right now we can only add X’s, but of course in Tic-Tac-Toe we also want to add O’s 2. Do this by adding the state variable [xIsNext, setXIsNext] with the default value of true in the Board component. The reason we are setting it to true is because X is the first player that will go. 1. We will also have to add an if statement to see if the xIsNext variable is true, and if it is then we set the next click to X, otherwise O. 2. However! This causes a problem where the state of the square can be overwritten by another click which is something that is impossible to do in Tic-Tac-Toe. We can fix this by first checking to see if the square is already filled, and if it is then we return the state of the board early before changing anything. Add the if statement that would help do this: if(squares[i]) { return; } 3. Add a new function outside the components called calculateWinner with the squares variable passed in. ``` function calculateWinner(squares) { const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6] ]; for (let i = 0; i < lines.length; i++) { const [a, b, c] = lines[i]; if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) { return squares[a]; } } return null; } ``` * Call this function in your handleClick function in the if statement to check if there is a winner. * Also call this function outside the handleClick function. Store the return value in a variable called winner. This will be used to show who the winner is after the game ends. Adding Move History 1. Now that you finished creating the basics of the tic-tac-toe game, let us go a little further and add a history function to the game. 2. If you remember from earlier, we used the .splice function to create copies of the board every time the board was changed. We can use this list of copies to display a list of past moves. 3. Declare a new export default function called Game(). This will be our main component now that will be used to display the board and the history of the game. Make sure to remove the export default keywords from the Board component from earlier. 4. Then, add state to the Game component that allows it to track which player is next and the history of the moves: ``` const [xIsNext, setXIsNext] = useState(true); const [history, setHistory] = useState([Array(9).fill(null)]); ``` 5. Then, create a currentSquares variable that will contain the latest information about the board. 6. Create a new function called handlePlay() with nextSquares passed in. This function will be called by the Board component to update the game. 7. Pass the props into the Board component to be used there. 8. Now, when the handlePlay() function is called, add the current board to the history state because the currentSquares variable is dependent on the history. Showing Past Moves 1. To show past moves, you will have to create individual buttons for each copy of the moves you made earlier. Right now, that is currently stored in the history state. 2. To do this, you will have to use the .map function of Javascript. This allows you to manipulate the history array to show which one you want to see. 3. You will be using this map function to read from the history array, and create a list of buttons with identifying descriptions. ``` const moves = history.map((squares, move) => { let description; if (move > 0) { description = 'Go to move #' + move; } else { description = 'Go to game start'; } return ( <li> <button onClick={() => jumpTo(move)}>{description}</button> </li> ); }); ``` 4. However, with this, you will run into a console warning that says each child in the array should have a unique key prop. You can fix this by specifying a specific key for each <li>. 1. For example, you can do <li key={move}>. This works because each past move has a unique id, the number of the move. Also, moves will never be changed as the history will always be constant. 5. Now let us implement the jumpTo() function. But before that, we have to keep track of which move the user is looking at. To do this, create a new state variable called currentMove that is defaulted to 0. 1. Then in the jumpTo() function, set the current move to the nextMove, and setXIsNext equal to true if currentMove is even. 6. Now, when you go back in time and decide to play a different move, you will want to alter the history so that it only shows up until the latest move. You can do this by once again using the .slice() function. 1. In the handlePlay() function, add this code: ``` const nextHistory = [...history.slice(0, currentMove + 1), nextSquares]; setHistory(nextHistory); setCurrentMove(nextHistory.length - 1); ``` 7. Now in the Game component, you will update the currentSquares variable to show the current move rather than the final move. 1. Const currentSquares = history[currentMove] 2. The board and the history buttons should work after this. 8. Is there any way we can make the code look cleaner? 1. We currently have xIsNext as a state variable that changes whenever a player moves. We can make this a normal variable that relies on the current value of the currentMove variable by checking to see if it is even or odd. 1. If you know what currentMove is, then we can mathematically figure out what currentMove is. 9. Finally, you are done! Congrats! Notes: I added some custom CSS to make the grid a little bigger (adjusted height and width of board to 100px) and added some description text for the Moves History section, and added a text that showed the user what move they are currently on.