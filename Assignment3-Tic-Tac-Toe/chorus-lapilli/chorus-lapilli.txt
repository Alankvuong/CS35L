Setting Up the Project 1. Open up your favorite IDE. For my project, I will be using VSCode. 2. Navigate to your directory of choice and run npx create-react-app chorus-lapilli to create your react project. 3. When your react project is created, you can proceed to delete the files you do not need. You only need the following files and directories: 1. Node_modules 2. Public folder 1. Index.html 3. Src folder 1. Index.js 2. Styles.css 4. Package-lock.json 5. Package.json Creating the Game 1. Open your index.js file. This is where you’ll be putting your code for the game. 2. At the top, you will need to import 3 things: 1. React 2. ReactDOM 3. styles.css (from earlier) 3. Lets now create our Board. 1. In order to create a board with 9 squares, you will need to create a Square component. Do this by making a function called Square() that returns a <button>. 2. Then, we have to create something that will call that Square component. 3. Create a function called generateSquare that accepts an index i as a parameter. This index i will serve as the index that will be passed into each square on the board. 1. In this function, return the Square component that you made earlier. 4. Then, create a render() function. This will be used to put everything together. 1. Return 3 divs. Each div will call the generateSquare function with index’s 0-8. 2. It should look like so: render() { return ( <div className="board-row"> {this.generateSquare(0)} {this.generateSquare(1)} {this.generateSquare(2)} </div> <div className="board-row"> {this.generateSquare(3)} {this.generateSquare(4)} {this.generateSquare(5)} </div> <div className="board-row"> {this.generateSquare(6)} {this.generateSquare(7)} {this.generateSquare(8)} </div> </div> ); } } 5. Then, create a class Game that extends the React.Component. 1. In here, create another render() that returns the overlying divs of the game and game board. 2. Inside, return this: <div className="game"> <div className="game-board"> <Board /> </div> 6. Now in your terminal, run the command: npm run start 1. On your localhost, you should now be able to see something like a board! 2. Fine tune how you want your board to look in your styles.css file. 7. Now let’s implement the logic for our game. Implementing the Logic 1. Create a class that extends React.Component called Board. 2. Create a constructor that will implement our state. This constructor will initialize all the variables we need to update. 1. Here are the states we will need: constructor(props) { super(props); this.state = { squares: Array(9).fill(null), xIsNext: true, moveCount: 0, selectedIndex: -1, adjacentSquares: Array(9).fill(false), }; } 3. Create a handleClick() function. 1. The purpose of this function is to handle any action that needs to be done when the user clicks a square in the board. 2. First, create a variable called squares that is a copy of the slice state variable. 3. Then, create an if statement to check if the user has won. If the user is a winner, end the game. Here is the calculateWinner function: function calculateWinner(squares) { const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6] ]; for (let i = 0; i < lines.length; i++) { const [a, b, c] = lines[i]; if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) { return squares[a]; } } return null; } 4. If there is not yet a winner, then put a piece down in an empty square. 1. Check if the square is empty before putting the piece down 2. Check if the moveCount is less than 6 3. Here is the code: // before there are 6 pieces on the board if(squares[i] === null && this.state.moveCount < 6) { squares[i] = currentPiece; this.setState({ squares: squares, xIsNext: !this.state.xIsNext, moveCount: this.state.moveCount + 1, selectedIndex: -1, adjacentSquares: Array(9).fill(false), }); 4. Or if the moveCount is more than 6, we have to handle the case a bit differently. This is because according to the rules of Chorus-Lapilli, we have to select a piece that we want to move. If there is a piece in the center, then we must either make a move that will win the game, or vacate the center space. The piece selected can only move adjacently. 1. Here is the code: else if(this.state.moveCount >= 6) { // after there are 6 pieces on the board if(squares[i] === currentPiece) { let centerPiece = (squares[4] === "X" && this.state.xIsNext) || (squares[4] === "O" && !this.state.xIsNext); this.setState({ squares: squares, xIsNext: this.state.xIsNext, moveCount: this.state.moveCount + 1, selectedIndex: i, adjacentSquares: this.findAdjacentSquare(i, centerPiece && i !== 4), // require a win if there is a piece in the center }); } else if(this.state.adjacentSquares[i]) { // then we select a piece to move squares[i] = currentPiece; squares[this.state.selectedIndex] = null; this.setState({ squares: squares, xIsNext: !this.state.xIsNext, moveCount: this.state.moveCount + 1, selectedIndex: -1, adjacentSquares: Array(9).fill(false), }); } 5. Notice how in the code above, we are calling a function called findAdjacentSquare. What does this do? 1. FInd adjacentSquare is a function that will check a piece’s adjacent squares that is available for it to move to. It will be used when we need to check what possible moves we have after having three pieces on the board. 2. Here is the code for findAdjacentSquare. // checks if there are any adjacent squares // if there is piece in center, can either move the center piece or move another piece if that can // win the game findAdjacentSquare(i, requireWin = false) { // return an array of all adjacent squares relative to current square (i) const squares = this.state.squares.slice(); if (squares[i] == null) { return null; } const adjacencyMap = [ [1, 3, 4], [0, 3, 4, 5, 2], [1, 4, 5], [0, 1, 4, 6, 7], [0, 1, 2, 3, 5, 6, 7, 8], [1, 2, 4, 7, 8], [3, 4, 7], [3, 4, 5, 6, 8], [4, 5, 7], ]; let adjacentSquares = Array(9).fill(false); if (i === 4 && squares[i] !== null) { for (const adjacent of adjacencyMap[i]) { if (squares[adjacent] === null) { adjacentSquares[adjacent] = true; } } return adjacentSquares; } for (const adjacent of adjacencyMap[i]) { if (squares[adjacent] !== null) { continue; } let copyOfSquares = [...squares]; copyOfSquares[adjacent] = squares[i]; copyOfSquares[i] = null; if (requireWin) { if (calculateWinner(copyOfSquares) !== null) { adjacentSquares[adjacent] = true; } } else { adjacentSquares[adjacent] = true; } } return adjacentSquares; } 6. Notice how we have an array called adjacencyMap. This is used to represent the adjacency matrix of a 3x3 grid. Each row in the array represents a square on the grid, and the numbers in the row correspond to the indices of the adjacent squares. For example, the first row [1, 3, 4] represents the top-left square, which is adjacent to the squares at indices 1, 3, and 4. The findAdjacentSquare function uses this array to determine the adjacent squares of a given square on the grid. 1. The for loop loops through this adjacency map and checks for any empty spots that can be moved to. If there is a center piece (dictated by the requiredToWIn parameter), then it forces us to move the centerpiece or another piece that would win the game. 4. Now going back to the components and functions that we implemented earlier, we have to add props! 1. In your Square component, pass in props as a parameter. This allows you to have access to all your state variables defined earlier. 2. Declare a default square color when the square is not being selected. White is easiest so lets do that. 3. Then, have an if statement that checks if there is currently a piece being moved. If there is a piece being moved, make the color of the adjacent squares light blue. Make the color of the piece being moved light green. 4. Then, in your button, add a style property and pass in your new background color css property. It should look like this: function Square(props) { let colorOfSquare = "white"; if (props.pieceBeingMoved) { colorOfSquare = "lightgreen"; } else if (props.isAdjacent) { colorOfSquare = "lightblue"; } return ( <button className="square" onClick={props.onClick} style={{ backgroundColor: colorOfSquare }} > {props.value} </button> ); 7. Further Customization 1. We want to show messages to the players when it is their turn, or when we want to instruct them further. 2. In your render function, add 3 divs: 1. One for status (shows the winner or whose turn it is) 2. One for the turn count 3. One for a status text that will instruct the player to select their piece and move it to an adjacent spot after all their pieces have already been placed 3. Also add this code at the top of the function to check for winners, or to change the statusText depending on the piece being played. const winner = calculateWinner(this.state.squares); let statusText = ""; let status; if (winner) { status = "Winner: " + winner; } else { status = "Next player: " + (this.state.xIsNext ? "X" : "O"); } let currentPiece = this.state.xIsNext ? "X" : "O"; if(this.state.moveCount >= 6) { statusText = "There are 3 " + currentPiece + "'s on the board. Select one of your pieces to move them." } 4. Add css accordingly to how you want your game to look. Congrats! You have successfully created Chorus Lapili! Results from running npm pack npm notice npm notice 📦 chorus-lapilli@0.1.0 npm notice === Tarball Contents === npm notice 3.4kB README.md npm notice 817B package.json npm notice 1.7kB public/index.html npm notice 5.8kB src/index.js npm notice 1.2kB src/styles.css npm notice === Tarball Details === npm notice name: chorus-lapilli npm notice version: 0.1.0 npm notice filename: chorus-lapilli-0.1.0.tgz npm notice package size: 4.4 kB npm notice unpacked size: 12.9 kB npm notice shasum: 137daf3812554505ac71a3caeaf483ebe30439ca npm notice integrity: sha512-QmSFB4tYVUI3X[...]ajdyIObXWVGdw== npm notice total files: 5 npm notice